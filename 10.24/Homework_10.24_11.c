#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>

int main() {


	//多种方法，建议看作业
	int a = 100;
	int b = 200;
	int i = 0;
	for (i = a; i <= b; i++) {      //优化，因为只有除了2奇数才可能是素数，所以从101-200，每次i加2
		int j = 0;
		int index = 0;
		for (j = 2; j < i; j++) {   //y = a*b, a,b中至少有一个数字小于等于根号y，
									// 16= 2*8，找2相当于找8，所以在2-根号y之间如
		//sqrt（）加头文件<math.h>	//果没有数字能被整除，那后面的数字没必要找了，因为16 = 2 * 8，
									//找2和找8等价
			if (i % j == 0) {
				index = 1;
				break;
			}
		}
		if (0 == index) {
			printf("%d ", i);
		}
	}
	//素数求解优化 可以自己去找，深挖
	

	//最优解：(12.13)
	int a = 100;
	int b = 200;
	int i = 0;
	int j = 0;
	//int index = 1;//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!index不能放在这
	for (i = a + 1; i <= b; i += 2) {
		// index放在这，每换一个i，index被初始化为1，否则，放在循环外面，一旦变成一次0，一直为0
		int index = 1;
		for (j = 2; j <= sqrt(i); j++) {
			if (i % j == 0) {
				index = 0;
				break;
			}
		}
		// if（index != 0） 或 if（index == 1）
		if (index) {
			printf("%d ", i);
		}
	}

	return 0;
}

// 答案：
/*
思路：
素数：即质数，除了1和自己之外，再没有其他的约数，则该数据为素数，具体方式如下
*/


//方法一：试除法
//int main()
//{
//	int i = 0;
//	int count = 0;
//
//
//	// 外层循环用来获取100~200之间的所有数据，100肯定不是素数，因此i从101开始
//	for (i = 101; i <= 200; i++)
//	{
//		//判断i是否为素数：用[2, i)之间的每个数据去被i除，只要有一个可以被整除，则不是素数
//		int j = 0;
//		for (j = 2; j < i; j++)
//		{
//			if (i % j == 0)
//			{
//				break;
//			}
//		}
//
//		// 上述循环结束之后，如果j和i相等，说明[2, i）之间的所有数据都不能被i整除，则i为素数
//		if (j == i)
//		{
//			count++;
//			printf("%d ", i);
//		}
//	}
//
//
//	printf("\ncount = %d\n", count);
//	return 0;
//}
//
//
////上述方法的缺陷：超过i一半的数据，肯定不是i的倍数，上述进行了许多没有意义的运算，因此可以采用如下
//// 方式进行优化
//// 方法二：每拿到一个数据，只需要检测其：[2, i/2]区间内是否有元素可以被2i整除即可，可以说明i不是素数
//int main()
//{
//	int i = 0;//
//	int count = 0;
//
//
//	for (i = 101; i <= 200; i++)
//	{
//		//判断i是否为素数
//		//2->i-1
//		int j = 0;
//		for (j = 2; j <= i / 2; j++)
//		{
//			if (i % j == 0)
//			{
//				break;
//			}
//		}
//		//...
//		if (j > i / 2)
//		{
//			count++;
//			printf("%d ", i);
//		}
//	}
//
//
//	printf("\ncount = %d\n", count);
//	return 0;
//}
//
//
//
//
///*
//方法二还是包含了一些重复的数据，再优化：
//如果i能够被[2, sqrt(i)]之间的任意数据整除，则i不是素数
//原因：如果 m 能被 2 ~ m-1 之间任一整数整除，其二个因子必定有一个小于或等于sqrt(m)，另一个大于或等于 sqrt(m)。
//*/
//int main()
//{
//	int i = 0;
//	int count = 0;
//
//
//	for (i = 101; i <= 200; i++)
//	{
//		//判断i是否为素数
//		//2->i-1
//		int j = 0;
//		for (j = 2; j <= sqrt(i); j++)
//		{
//			if (i % j == 0)
//			{
//				break;
//			}
//		}
//		//...
//		if (j > sqrt(i))
//		{
//			count++;
//			printf("%d ", i);
//		}
//	}
//
//
//	printf("\ncount = %d\n", count);
//	return 0;
//}
//
//
////方法4
///*
//继续对方法三优化，只要i不被[2, sqrt(i)]之间的任何数据整除，则i是素数，但是实际在操作时i不用从101逐渐递增到200，因为出了2和3之外，不会有两个连续相邻的数据同时为素数
//*/
//
//
//int main()
//{
//	int i = 0;
//	int count = 0;
//
//
//	for (i = 101; i <= 200; i += 2)
//	{
//		//判断i是否为素数
//		//2->i-1
//		int j = 0;
//		for (j = 2; j <= sqrt(i); j++)
//		{
//			if (i % j == 0)
//			{
//				break;
//			}
//		}
//		//...
//		if (j > sqrt(i))
//		{
//			count++;
//			printf("%d ", i);
//		}
//	}
//
//	printf("\ncount = %d\n", count);
//	return 0;
//}